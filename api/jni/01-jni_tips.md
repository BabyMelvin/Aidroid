#JNI
JNI是java的底层接口。JNI定义java或kotlin字节码和底层(C/C++)交互的方式。编译厂商中立，有时麻烦也是合理有效的。
1.什么时候需要使用JNI本地方法：

* 标准JAVA库不支持应用要求平台独立的特征。
* 已经用其他语言写好了的库，通过JNI能够使用JAVA代码获得到。
* 想要获得小部分时间很重要的代码，通过底层代码，比如汇编。

2.JNI用本地方法能够做什么：

* 创建，检测和更新JAVA对象(包括数组和字符串)
* 调用JAVA方法
* 获取或抛出异常
* 加载类和获得类的信息
* 实施运行类型检查

同样,通过JNI调用API能到将动态底层应用嵌入到JAVA VM中.

## JNI接口函数和指针
本地代码获得JAVA VM特征，通过调用JNI函数。JNI函数通过一个接口指针获得。一个接口指针是一个指向指针的指针。这个指针指向一个指针数组，数组中的指针是函数接口。每个接口是数组中预定义的偏移。

<image src="image/01-01.png"/>
JNI接口组织类似C++虚函数表，或者COM接口。不用硬链接接口而使用接口表好处是JNI名称空间是独立本地的代码。一个VM可以很容易童工做个版本的JNI函数表。例如，VM可以提供两个JNI函数表：

* 一个为了非法参数检查，并且很适合调试。
* 另一个来对JNI规范要求的最少数量的检测，因此更有效率。

JNI接口指针仅仅在当前线程才能获得。因此，一个本地方法不能够将接口指针从一个线程传递给另一个线程。一个VM实现JNI可能分配和存储本地线程数据在JNI接口指针指向的地方。

本地方法接收JNI接口指针作为一个参数。从java同一个线程，VM保证传递对个对本地接口的访问。然而一个本地方法可能被多个不同的java线程访问，因此，可能接收不同的java接口指针。

## 编译，加载和链接本地方法
由于JavaVM使多线程的，本地库也应该通过多线程的编译器来编译和连接。例如，SUN Studio编译器用`-mt`来编译C++代码.GNU的gcc编译器使用`-D_REENTRANT`或者是`-D_POSIX_C_SOURCE`.加载包含f函数的平台相关的库方法:

```java
package pkg;
class Cls{
	native double f(int i,String s);
	static{
		System.loadLibrary("pkg_Cls");
	}
}
```

也能够使用JNI函数`RegisterNatives()`注册和这类相关的本地方法。对静态连接函数，函数`RegisterNatives()`函数很有用。

## 本地方法名

动态连接通过他们完整的名字完成。本地方法包含下面部分：

* 前缀Java_
* 完整类名
* 下划线来分割
* 完整的方法名
* 重载本地方法，签名参数后加双下划线`__`

VM检查方法和本地库中匹配。首先找不带参数签名的短名称，然后检查带长名称的名字。

## java对象引用
原始类型如整型，字符等java和native代码保存两份。任意java对象都是通过引用传递。VM必须保持追踪多有的传递到native的对象，保证这些对象不会被垃圾回收器回收。相对的，natvie代码必须有一种方式通知VM某对象不再需要。另外，垃圾回收器必须能够移除被本地代码引用的对象。

### 本地引用和全局引用
JNI将被本地使用对象的引用分为两类：本地和全局引用。

* 本地引用在本地方法调用有效，能够在本地方法返回后自动释放。
* 全局引用一直保持，直到主动释放为止。

* 对像传递到native是作为有一个本地引用。所有的本地返回JAVA对象都是一个本地引用。
* JNI允许从本地引用创建成全局引用。JNI函数希望JAVA对象能够接受本地和全局引用。一个本地方法可能返回一个本地或者全局引用作为结果返回给VM。

大部分情况，想通过VM来自动释放本地引用。但是，有些时候，想要主动释放本地引用。例如：

* 本地方法获得大的Java对象，同时创建一个本地对java对象的引用。native对象在返回之前进行一些计算。本地引用被回收，即使在接下来的计算不再需要了。
* 本地方法创建很多本地引用，虽然他们并不是同时使用。既然VM需要一定空间保持本地引用，创建太多的引用会导致系统内存溢出。例如，native方法中通过一个大的结构体来循环，但是每次循环重复创建，每次结束不在需要该本地引用。

JNI允许主动删除不再需要的本地引用。为了保证释放本地引用，JNI不允许创建另外的本地引用，除非他们作为返回的结果。

本地引用只有在被创建线程中有效。不能传递给其他线程。

### 实现本地引用
为了实现本地引用，Java VM对java到native方法对每次传输创建一个注册表。注册表映射不变动本地引用对java对象，保持该对象被回收。

* 所有java对象传递给本地方法都自动添加到注册表。
* 本地方法返回，注册表将会被删除，允许它的全部内容被垃圾回收

很多种不同的方法来实现注册表，表、链表或指针。虽然引用计数能够避免在注册表中重复记录，但是JNI实现不再是检测和重复进入。

记住，本地引用不再是简单通过扫描本地栈。本地代码能够存储本地引用在全局或堆数据结构中。

## 获得java对象
JNI提供很多本地和全局方法来获得。意味着本地方法实现不管VM如何内部呈现java对象。这也是为什么JNI能够支持VM各式各样的实现。

获得一种很好的方法是通过一个模糊的引用而不是直接对C结构体访问。在大多数情况下，java编程者使用native方法执行重要的任务，这任务忽略了接口访问的代价。

### 获得原始数组
包含许多数据，如整型数组和字符串的大的java对象开销是不可接受的。通过迭代和获得每个元素在函数调用中是相当没有效率的。

一个方法是引用“pinning”概念，为了本地方法让VM标记数组内容。然后本地方法直接获得元素通过指针。这个方法，有两个启示：

* 回收器必须支持标记机制
* VM必须在内存中连续列出原始数组。虽然这是大多数数组的实现，但是Boolean数组能被实现打包或不打包方式。因此，本地方法依赖具体Boolean数组的方式不能被移植的。

采取这种办法解决上面两个问题。

首先，我们应该提供一个函数来对原始数组原始在java数组和本地内存缓冲进行拷贝。如果在大数组中仅获得几个元素，那么使用这个方法。

第二，能够使用另一种方法获得被标记的元素的版本。记住，这些函数需要获得java vm分配和拷贝。是否这些函数正真拷贝依赖于VM的实现：

* 如果垃圾回收器支持标记机制，并且数组分布和本地想要的方式一样，那么就不需要拷贝。
* 否则，数组被拷贝到不变内存块(比如，C的堆)必要的传输格式被执行，待拷贝指针被返回。

最后，接口提供函数通知VM，本地代码不在需要获得数组元素。当你调用这些函数，系统要么解标记数组，或者重新分配一个不变拷贝并且释放原来的拷贝。

一个JNI实现必须保证native方法能够同时运行多线程获得同一个对象。例如，JNI可以在没给标记数组技术为了在另一个线程中标记，这个线程不能解标记。JNI不需要通过native方法锁定一个原始数组来排除访问情况。同时，从不同线程更新一个数组导致不定的结果。

## 获得一个属性和方法

JNI允许获得java对象的一个属性和调用方法。JNI识别方法和属性通过标记和签名类型。
例如，调用cls类中f方法，首先获得方法id

```cpp
jmethodID mid=env->GetMethodID(cls,"f","(ILjava/lang/String;)D");
```
然后就可以重复使用该方法，而不需要寻找方法的花费。：

```cpp
jdouble result=env->CallDoubleMethod（obj,mid,10,str）;
```

一个属性或一个方法不会阻止该方法的类的卸载。类卸载后，方法无效。因此本地方法要保证:

* 潜在类要保活，否者重新获取方法和类。

JNI不能够导入任何任何属性或方法的内部实现。

## 编程报错

JNI不检查NULL或非法参数。JNI不检查这错误类型使因为:

* 强制检查会降低本地代码性能
* 大多数通知类型也不需要去检查。


