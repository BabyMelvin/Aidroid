
/****************************************************************************************/
/*                          COPYRIGHT INFORMATION                                       */
/*    All rights reserved:shuaifengyun@126.com.                                         */
/****************************************************************************************/
/*
 ****************************************************************************************
 *
 *               CryptoVerifyCaTest.c
 *
 * Filename      : CryptoVerifyCaTest.c
 * Author        : Shuai Fengyun
 * Mail          : shuai.fengyun@126.com
 * Create Time   : Thu 12 Nov 2015 04:05:30 PM CST
 ****************************************************************************************
 */



/** @defgroup MODULE_NAME_INFOR
* @{
*/

/*
 *******************************************************************************
 *                                INCLUDE FILES
 *******************************************************************************
*/
#include "CryptoVerifyCa.h"
#include "CryptoVerifyCaDebug.h"
#include "CryptoVerifyType.h"
#include "CryptoVerifyCaDebug.h"


/*
 *******************************************************************************
 *                         FUNCTIONS SUPPLIED BY THIS MODULE
 *******************************************************************************
*/





/*
 *******************************************************************************
 *                          VARIABLES SUPPLIED BY THIS MODULE
 *******************************************************************************
*/





/*
 *******************************************************************************
 *                          FUNCTIONS USED ONLY BY THIS MODULE
 *******************************************************************************
*/





/*
 *******************************************************************************
 *                          VARIABLES USED ONLY BY THIS MODULE
 *******************************************************************************
*/
/* Buffer for random operation */
CHAR g_RandomOut[512] = {0};

/* Buffer for sha operation */
CHAR g_ShaTestBuf[] ={
     'Y', 'o', 'u', ' ', 'y', 'o', 'u', ' ', 'c', 'h', 'e', 'c', 'k', ' ', 'n', 'o',
     'w', 'j', 'i', 'a', 'n', ' ', 'b', 'i', 'n', 'g', ' ', 'g', 'u', 'o', ' ', 'z',
     'i', ' ', 'l', 'a', 'i', ' ', 'y', 'i', ' ', 't', 'a', 'o', '!', '!', '!', '!'};
CHAR g_ShaOutput[80] = {0};

/* Buffer for aes operation */
CHAR g_AesRawBuf[]    = "Come On! You! You! check now,jian bing guo zi lai yi tao! yeah!";
CHAR g_AesEcbRawBuf[] = "~~~~~You! You! check now, jian bing guo zi lai yi tao! yeah~~~~";

CHAR g_AesEncCbcBuf[] = 
{
    0x3f, 0x25, 0x9f, 0x5e, 0x43, 0xbe, 0x50, 0x03, 0x86, 0x6d, 0xc4, 0x28, 0xf3, 0x01, 0xb6, 0xfb, 
    0x98, 0x47, 0xd3, 0xc6, 0x34, 0xd2, 0xe2, 0x55, 0x59, 0xc9, 0xd8, 0x8b, 0xdf, 0x5b, 0xc2, 0xbc, 
    0x7e, 0xd8, 0xfe, 0xea, 0x03, 0xea, 0x99, 0xeb, 0x67, 0x5b, 0xdf, 0x58, 0x88, 0x43, 0x54, 0x16, 
    0x86, 0x86, 0x57, 0x77, 0xd4, 0xa6, 0x95, 0xad, 0x63, 0x33, 0x9b, 0x51, 0x3d, 0x1c, 0x17, 0x5f
};
CHAR g_AesEncEcbBuf[] =  
{
    0x3c, 0x48, 0xeb, 0x65, 0x3e, 0xaf, 0xaf, 0x56, 0x57, 0xfa, 0xbb, 0x6f, 0x0b, 0x0b, 0x65, 0x3c, 
    0x11, 0xf3, 0x5a, 0xe3, 0x58, 0xc9, 0xcc, 0xe1, 0xad, 0x0e, 0x16, 0x0e, 0x84, 0x07, 0xf9, 0x2b, 
    0x04, 0x57, 0x18, 0xa3, 0xf1, 0x4f, 0x41, 0xf8, 0xf2, 0xe6, 0xfa, 0x89, 0x7c, 0x94, 0x73, 0x5f, 
    0xbb, 0x48, 0x4b, 0xba, 0xd5, 0x39, 0x6e, 0xc2, 0x5c, 0xd1, 0x29, 0xf8, 0x42, 0x10, 0xb0, 0x6f
};
CHAR g_AesEncCtrBuf[] =  
{
    0x6d, 0xa6, 0xa7, 0x9b, 0x4f, 0xe6, 0xb2, 0x2f, 0x77, 0x2b, 0x40, 0x9d, 0x7d, 0xdf, 0x02, 0x9a, 
    0x9c, 0x15, 0xc3, 0x84, 0xb5, 0x90, 0x2f, 0x5d, 0x7a, 0xe2, 0xef, 0x3e, 0xec, 0x18, 0x60, 0x26, 
    0x42, 0xf2, 0x82, 0x5c, 0x58, 0x42, 0xfc, 0x9b, 0x20, 0x80, 0x56, 0x62, 0x03, 0xc8, 0x0f, 0x25, 
    0xaa, 0x7f, 0xe3, 0x00, 0x29, 0xf1, 0x9f, 0x8a, 0x9b, 0x4b, 0xd5, 0xfa, 0xf0, 0x7c, 0xa8, 0xe1
};
CHAR g_AesEncCtsBuf[] =  
{
    0x3f, 0x25, 0x9f, 0x5e, 0x43, 0xbe, 0x50, 0x03, 0x86, 0x6d, 0xc4, 0x28, 0xf3, 0x01, 0xb6, 0xfb, 
    0x98, 0x47, 0xd3, 0xc6, 0x34, 0xd2, 0xe2, 0x55, 0x59, 0xc9, 0xd8, 0x8b, 0xdf, 0x5b, 0xc2, 0xbc, 
    0x7e, 0xd8, 0xfe, 0xea, 0x03, 0xea, 0x99, 0xeb, 0x67, 0x5b, 0xdf, 0x58, 0x88, 0x43, 0x54, 0x16, 
    0x86, 0x86, 0x57, 0x77, 0xd4, 0xa6, 0x95, 0xad, 0x63, 0x33, 0x9b, 0x51, 0x3d, 0x1c, 0x17, 0x5f
};

CHAR g_AesOutpUT[256] = {0};


/* Buffer for sha operation */
CHAR g_HmacTestBuf[] ={
     'Y', 'o', 'u', ' ', 'y', 'o', 'u', ' ', 'c', 'h', 'e', 'c', 'k', ' ', 'n', 'o',
     'w', 'j', 'i', 'a', 'n', ' ', 'b', 'i', 'n', 'g', ' ', 'g', 'u', 'o', ' ', 'z',
     'i', ' ', 'l', 'a', 'i', ' ', 'y', 'i', ' ', 't', 'a', 'o', '!', '!', '!', '!'};
CHAR g_HmacOutput[80] = {0};




CHAR g_PbkdfOut[32] = {0};



CHAR g_RsaPaddingRaw1[] = "YAO YAO qie ke nao! Zai han leng de dong tian lai tao jian bing guo zi, you!";

CHAR g_RsaPcks1Dec1[] = 
{

0x0e, 0x52, 0x45, 0xcc, 0x6a, 0x5e, 0xbd, 0xae, 0x6c, 0x25, 0x59, 0xf2, 0x07, 0xb5, 0x3e, 0xc2, 
0x6b, 0x2d, 0xae, 0x66, 0xe7, 0x68, 0xc3, 0x86, 0xa9, 0xb2, 0x5c, 0x59, 0x76, 0x3e, 0x1e, 0x16, 
0xd4, 0xd9, 0xa8, 0x84, 0xe5, 0x9b, 0x4d, 0x4d, 0x49, 0xff, 0x4f, 0x46, 0x27, 0x35, 0x2b, 0x97, 
0x6b, 0x90, 0x1c, 0x6b, 0x0b, 0x76, 0xc8, 0x40, 0x35, 0x84, 0x8d, 0x84, 0xec, 0xad, 0xed, 0xfc, 
0x34, 0x62, 0xea, 0xf3, 0xfa, 0xb8, 0x30, 0xe4, 0xa0, 0x75, 0x47, 0x91, 0xf7, 0xa7, 0xc7, 0x3f, 
0xbd, 0x9a, 0x95, 0x78, 0x1e, 0x18, 0x70, 0x11, 0x32, 0xa8, 0x07, 0x1c, 0x01, 0x30, 0xa4, 0x05, 
0x5e, 0xc8, 0x41, 0x60, 0x32, 0xaa, 0xce, 0xdd, 0xe2, 0x47, 0xe5, 0x56, 0x8a, 0x07, 0xb3, 0xaf, 
0x59, 0x74, 0xc6, 0x3b, 0xce, 0x59, 0xed, 0xab, 0x08, 0x91, 0x9f, 0x73, 0x0e, 0xf9, 0x7d, 0xcd,
};


CHAR g_RsaPcks1Verify1[] = 
{
    0x58, 0xc7, 0x2c, 0x94, 0x96, 0xf7, 0x18, 0x87, 0x43, 0xb3, 0x1c, 0xf8, 0x81, 0x8d, 0x62, 0xe3, 
    0xcd, 0xa8, 0xcb, 0x26, 0x27, 0x7d, 0x7f, 0x9c, 0xa4, 0x32, 0x65, 0x52, 0x27, 0x63, 0xcb, 0x0d, 
    0xa1, 0xa1, 0x1a, 0x03, 0x19, 0x05, 0x3f, 0xfe, 0x8a, 0x50, 0xc7, 0xfe, 0x63, 0xff, 0x2c, 0x61, 
    0xaa, 0x1d, 0x7f, 0x86, 0x18, 0x3c, 0x24, 0x0b, 0xe8, 0x6e, 0x22, 0xdb, 0x65, 0xf8, 0xf5, 0x7f, 
    0x06, 0x8f, 0x2a, 0xc3, 0x68, 0x8d, 0xe1, 0x93, 0x5a, 0xa2, 0x76, 0x38, 0x84, 0x20, 0x4b, 0xbb, 
    0xfd, 0x2c, 0xb6, 0xc4, 0x2b, 0xe2, 0xcf, 0xe6, 0x46, 0xf2, 0x25, 0x6f, 0x5b, 0x80, 0xe7, 0x87, 
    0xab, 0xe1, 0xd7, 0x54, 0xfc, 0x95, 0xf8, 0xa1, 0x5a, 0x79, 0x0e, 0xad, 0x4d, 0x32, 0x37, 0xd0, 
    0x7c, 0xdc, 0x7f, 0x9a, 0x2a, 0x69, 0xd1, 0x20, 0x5d, 0xa2, 0xde, 0x81, 0x24, 0x43, 0x9a, 0x09
};


CHAR g_Output1024[128] = {0};

CHAR g_RsaPaddingRaw2[] = "YAO YAO qie ke nao! Zai han leng de dong tian lai tao jian bing guo zi, you!"; 

CHAR g_RsaPcks1Dec2[] = 
{
    0x4c, 0x55, 0x27, 0x99, 0x93, 0xfa, 0x76, 0xac, 0xfc, 0xfe, 0xd3, 0xca, 0xc7, 0x74, 0x5f, 0x9d, 
    0x41, 0xe8, 0x64, 0x8b, 0xb3, 0x0b, 0x97, 0xe4, 0x99, 0x84, 0x1f, 0x1b, 0x1f, 0xf5, 0x33, 0xff, 
    0x94, 0x68, 0x44, 0x9b, 0xb0, 0x50, 0xf8, 0xa4, 0xa9, 0x4a, 0x9b, 0x44, 0x7d, 0x81, 0xec, 0x0d, 
    0x3f, 0x03, 0x18, 0x23, 0x61, 0xc1, 0xfc, 0x77, 0x03, 0xa5, 0xad, 0x7e, 0x47, 0xc7, 0xc6, 0x11, 
    0x6d, 0xd2, 0x25, 0x17, 0x8e, 0xe0, 0xbc, 0x07, 0xe2, 0x05, 0xa3, 0xda, 0x67, 0x32, 0xb4, 0x3e, 
    0xdc, 0x35, 0x52, 0x3e, 0x6a, 0x56, 0xc9, 0x17, 0x4e, 0xaa, 0x78, 0xba, 0x29, 0x31, 0xa8, 0xbe, 
    0x76, 0xf0, 0x26, 0x19, 0x5f, 0x9a, 0x0f, 0x2a, 0xb5, 0xa2, 0x8c, 0xe0, 0x0d, 0x6a, 0x65, 0x7d, 
    0x96, 0xcc, 0xba, 0xbb, 0x8f, 0x32, 0xe8, 0x81, 0xc1, 0x21, 0x22, 0x0e, 0x1c, 0xb0, 0x52, 0xb2, 
    0xe0, 0x27, 0xb7, 0x91, 0xeb, 0x66, 0x33, 0xa1, 0xa2, 0xbc, 0x3f, 0x84, 0xc3, 0xdf, 0x09, 0x62, 
    0x76, 0xbe, 0x36, 0x66, 0x83, 0x84, 0x74, 0x6d, 0x97, 0x3e, 0xe1, 0x40, 0x18, 0xbd, 0x3a, 0xca, 
    0x9c, 0x3a, 0x4c, 0xbf, 0x25, 0x5a, 0xf1, 0xf2, 0xe6, 0x6c, 0xf7, 0xef, 0x55, 0xc7, 0x01, 0x58, 
    0xdb, 0x65, 0xf5, 0x42, 0x97, 0xf1, 0x2d, 0x69, 0x3d, 0xe8, 0x2c, 0x7d, 0xed, 0x6e, 0xa6, 0xb9, 
    0x46, 0x67, 0x10, 0x1e, 0x8c, 0xc5, 0x64, 0x76, 0x02, 0x0d, 0x6d, 0x17, 0x1b, 0xe9, 0xb7, 0x1e, 
    0x53, 0xdf, 0x82, 0xb8, 0x82, 0x82, 0x67, 0x2d, 0x5c, 0x76, 0xc7, 0x3f, 0x8b, 0x5e, 0x54, 0x49, 
    0xc7, 0xdf, 0xec, 0x08, 0xbb, 0xd6, 0x46, 0x8f, 0xf9, 0x74, 0x6a, 0x0e, 0x5a, 0x40, 0x11, 0x0d, 
    0x8a, 0xf0, 0xdb, 0xc4, 0xc0, 0xa8, 0x78, 0x27, 0x70, 0x3a, 0xdd, 0xf2, 0xeb, 0x2c, 0x8b, 0x00

};



CHAR g_RsaPcks1Verify2[] = 
{
    0x81, 0x72, 0xdf, 0xd4, 0xee, 0x12, 0x43, 0xe2, 0xb6, 0xe6, 0x46, 0xc7, 0x5b, 0x99, 0x7b, 0xec, 
    0x36, 0x41, 0x13, 0xb8, 0xa9, 0xb7, 0x10, 0xf6, 0xb8, 0x5d, 0x95, 0xcd, 0x65, 0x64, 0x83, 0xb1, 
    0xe1, 0x2f, 0xe2, 0xa0, 0x07, 0x2e, 0xac, 0x80, 0x56, 0xed, 0x9c, 0xcf, 0x54, 0x31, 0xdc, 0x3e, 
    0x0c, 0xb7, 0x93, 0xdf, 0xe8, 0xc0, 0x38, 0x80, 0xd6, 0x80, 0xc0, 0x66, 0xcb, 0x79, 0x9f, 0x12, 
    0xbf, 0x22, 0x21, 0x6a, 0xc2, 0x11, 0xe8, 0x04, 0x53, 0xa8, 0x1e, 0x5f, 0x1d, 0xaa, 0xdb, 0xcc, 
    0x33, 0x27, 0x6a, 0xe8, 0xa3, 0x15, 0x35, 0xbe, 0x52, 0x08, 0x33, 0x7b, 0xb1, 0x52, 0x15, 0x6b, 
    0x60, 0xd9, 0xa0, 0x94, 0xb2, 0xa1, 0x4f, 0x06, 0x1f, 0xfe, 0x4f, 0xa7, 0x9c, 0x99, 0x42, 0x30, 
    0x8e, 0xab, 0xee, 0xac, 0x0c, 0x8c, 0x6c, 0xd9, 0x2b, 0xc6, 0xbc, 0x82, 0xde, 0x26, 0x8c, 0x33, 
    0x84, 0xe6, 0x31, 0x9b, 0x39, 0xd4, 0xb7, 0x38, 0x45, 0xfa, 0x2f, 0xf7, 0xf1, 0x09, 0xd4, 0x56, 
    0xab, 0x63, 0xe7, 0xb0, 0xd3, 0x8a, 0x3a, 0x6c, 0x61, 0x15, 0x1e, 0xf4, 0xc3, 0x4e, 0xce, 0x19, 
    0xed, 0x3b, 0xd9, 0xed, 0xd2, 0x8f, 0xfa, 0x39, 0x67, 0x4c, 0x48, 0xde, 0x69, 0x27, 0x85, 0x76, 
    0xdd, 0x93, 0xd8, 0x59, 0x81, 0x4a, 0xde, 0x38, 0xd5, 0x24, 0x49, 0x4b, 0xcc, 0x74, 0x2e, 0x5b, 
    0xfd, 0xa2, 0x4b, 0xd4, 0xd4, 0x43, 0x03, 0x60, 0xf0, 0x67, 0x8d, 0xb0, 0x02, 0x95, 0x0b, 0xd7, 
    0x6c, 0xb7, 0x56, 0x2d, 0x08, 0x01, 0xb5, 0x4a, 0xe1, 0x35, 0x87, 0xad, 0x91, 0x7e, 0x63, 0xed, 
    0x78, 0x9d, 0x61, 0xe5, 0x6e, 0xb2, 0x16, 0x39, 0xea, 0xb8, 0x7f, 0x3b, 0x65, 0x17, 0xa9, 0xad, 
    0x54, 0x57, 0x28, 0xc6, 0xc2, 0xb3, 0x84, 0x31, 0x15, 0xb5, 0xae, 0x66, 0x99, 0xe6, 0xdf, 0x68

};


CHAR g_Output2048[256] = {0};




/********************Result of crypto API from TA*******************************************/
CHAR g_Sha1Result[] = 
{   
    0x21, 0x9b, 0x5b, 0x8b, 0x25, 0x6f, 0x0e, 0x52, 0xcb, 0x2f, 0xfe, 0xfd, 0x6c, 0x47, 0xd7, 0xb4, 
    0x44, 0x00, 0x57, 0xc3
};


CHAR g_Sha256Result[] = 
{   
    0xda, 0x52, 0xe9, 0xc2, 0x53, 0xae, 0x03, 0x30, 0xbd, 0x97, 0x3f, 0xa5, 0xf3, 0xea, 0x51, 0x1d, 
    0x31, 0x0a, 0xdf, 0x1f, 0x0a, 0xc0, 0x0e, 0x62, 0x0f, 0x2d, 0x5e, 0x99, 0xf5, 0xc8, 0x6b, 0x8f
};



/********************   BASE64*******************************************/
CHAR g_Base64Raw[372] = 
{
    0x00, 0x01, 0x00, 0x00, 0x11, 0x12, 0x13, 0x14, 0x15, 0x23, 0x41, 0xa2, 0xa1, 0xa2, 0xa3, 0xa4, 
    0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0x2a, 0x2b, 0x2c, 0xba, 0x4a, 0x6e, 0xb9, 0xef, 0xf2, 0x20, 0x00,
    0x00, 0x01, 0x00, 0x50, 0xb7, 0x9b, 0x18, 0x4b, 0xec, 0x06, 0xee, 0xae, 0x62, 0xce, 0x1d, 0x01, 
    0x5b, 0xc7, 0xd3, 0x00, 0x3d, 0x92, 0xc0, 0xdc, 0x2a, 0x0e, 0x0a, 0x14, 0x4a, 0xcc, 0x35, 0x46, 
    0xb7, 0xbc, 0x6b, 0x23, 0x67, 0xd9, 0x46, 0xc2, 0xd1, 0x84, 0x17, 0xb1, 0x12, 0xe4, 0xdf, 0xe2, 
    0x57, 0xdc, 0x40, 0xa9, 0xa6, 0x7e, 0x00, 0xe5, 0xac, 0x0e, 0xa4, 0x06, 0x58, 0xe4, 0xf5, 0x1d, 
    0x2e, 0x83, 0x4a, 0x05, 0x5e, 0x52, 0xe2, 0xf4, 0xc0, 0xb0, 0x23, 0x64, 0x4c, 0xcc, 0x62, 0x1b, 
    0x1a, 0x52, 0x4e, 0x8b, 0x34, 0x5f, 0x93, 0xb6, 0x13, 0xac, 0x0f, 0xce, 0x57, 0x54, 0xf6, 0xc1, 
    0xd3, 0xea, 0xef, 0x7c, 0xdd, 0x9e, 0xb2, 0xf6, 0x3c, 0x78, 0x53, 0x1d, 0xe2, 0xbe, 0xba, 0xdc, 
    0xa1, 0x43, 0xf9, 0xb0, 0x9a, 0xcd, 0x35, 0x52, 0x06, 0x65, 0xe4, 0xb8, 0x39, 0xdf, 0x9b, 0x4c, 
    0x81, 0xd4, 0x12, 0x37, 0x81, 0x68, 0x49, 0x8f, 0xa9, 0x09, 0x77, 0x2d, 0x92, 0x57, 0x55, 0x1b, 
    0x79, 0x9a, 0x01, 0x17, 0xc5, 0x98, 0x93, 0xb9, 0xb7, 0x2b, 0xcb, 0xf2, 0x45, 0x63, 0xfe, 0xd2, 
    0xe9, 0x82, 0xe2, 0xb3, 0xd5, 0xe5, 0x63, 0x2f, 0xb3, 0xbb, 0xb4, 0xd7, 0x98, 0xc0, 0x3f, 0x30, 
    0x82, 0x60, 0x18, 0x84, 0x44, 0x58, 0x6e, 0xd0, 0x72, 0x76, 0x90, 0x62, 0x2a, 0x39, 0xba, 0xfa,
    0xf6, 0xf6, 0x5a, 0x8f, 0x73, 0x79, 0xe4, 0xbd, 0x2b, 0xce, 0x0c, 0x34, 0x98, 0x72, 0x56, 0xed, 
    0x1f, 0x67, 0xdb, 0x79, 0xf4, 0xad, 0x86, 0x63, 0xed, 0xcb, 0x17, 0xdf, 0x54, 0xf0, 0x20, 0xf4, 
    0xbd, 0x56, 0x7e, 0x29, 0x24, 0xe5, 0x3f, 0x23, 0x72, 0x82, 0xf4, 0xf8, 0x54, 0x56, 0x0b, 0x9a, 
    0x25, 0xc3, 0xfa, 0x03, 0x42, 0xc7, 0x43, 0x84, 0x64, 0x46, 0xd6, 0xc1, 0x47, 0xf7, 0x9a, 0xba, 
    0xb1, 0x85, 0xae, 0x57, 0x04, 0x54, 0x62, 0x82, 0xd9, 0x80, 0x12, 0x97, 0x18, 0xaf, 0xc4, 0x06, 
    0xb8, 0xf3, 0x35, 0xf5, 0x02, 0x17, 0xaa, 0xe9, 0x0d, 0x9e, 0x6c, 0x48, 0x57, 0x8f, 0xea, 0xad, 
    0x23, 0x37, 0x3f, 0xbf, 0xd6, 0x1f, 0x32, 0x04, 0x01, 0x41, 0x03, 0x27, 0xa3, 0xd2, 0x1d, 0xf5,
    0x2a, 0x79, 0xcf, 0x8a, 0x45, 0x25, 0xc2, 0x30, 0x4c, 0x8d, 0xda, 0x1b, 0x6a, 0x12, 0x04, 0x3f, 
    0xd3, 0x9a, 0xa9, 0xdc, 0xe3, 0x08, 0xf2, 0x6e, 0x00, 0x01, 0xbc, 0x4e, 0x62, 0x26, 0xd9, 0x12, 
    0x5c, 0xfc, 0x97, 0x5c
};

CHAR g_Base64out[500] = {0};

CHAR g_Base64enced[496] = 
{
    0x41, 0x41, 0x45, 0x41, 0x41, 0x42, 0x45, 0x53, 0x45, 0x78, 0x51, 0x56, 0x49, 0x30, 0x47, 0x69, 
    0x6f, 0x61, 0x4b, 0x6a, 0x70, 0x4b, 0x57, 0x6d, 0x70, 0x36, 0x69, 0x70, 0x4b, 0x69, 0x73, 0x73, 
    0x75, 0x6b, 0x70, 0x75, 0x75, 0x65, 0x2f, 0x79, 0x49, 0x41, 0x41, 0x41, 0x41, 0x51, 0x42, 0x51, 
    0x74, 0x35, 0x73, 0x59, 0x53, 0x2b, 0x77, 0x47, 0x37, 0x71, 0x35, 0x69, 0x7a, 0x68, 0x30, 0x42, 
    0x57, 0x38, 0x66, 0x54, 0x41, 0x44, 0x32, 0x53, 0x77, 0x4e, 0x77, 0x71, 0x44, 0x67, 0x6f, 0x55, 
    0x53, 0x73, 0x77, 0x31, 0x52, 0x72, 0x65, 0x38, 0x61, 0x79, 0x4e, 0x6e, 0x32, 0x55, 0x62, 0x43, 
    0x30, 0x59, 0x51, 0x58, 0x73, 0x52, 0x4c, 0x6b, 0x33, 0x2b, 0x4a, 0x58, 0x33, 0x45, 0x43, 0x70, 
    0x70, 0x6e, 0x34, 0x41, 0x35, 0x61, 0x77, 0x4f, 0x70, 0x41, 0x5a, 0x59, 0x35, 0x50, 0x55, 0x64, 
    0x4c, 0x6f, 0x4e, 0x4b, 0x42, 0x56, 0x35, 0x53, 0x34, 0x76, 0x54, 0x41, 0x73, 0x43, 0x4e, 0x6b, 
    0x54, 0x4d, 0x78, 0x69, 0x47, 0x78, 0x70, 0x53, 0x54, 0x6f, 0x73, 0x30, 0x58, 0x35, 0x4f, 0x32, 
    0x45, 0x36, 0x77, 0x50, 0x7a, 0x6c, 0x64, 0x55, 0x39, 0x73, 0x48, 0x54, 0x36, 0x75, 0x39, 0x38, 
    0x33, 0x5a, 0x36, 0x79, 0x39, 0x6a, 0x78, 0x34, 0x55, 0x78, 0x33, 0x69, 0x76, 0x72, 0x72, 0x63, 
    0x6f, 0x55, 0x50, 0x35, 0x73, 0x4a, 0x72, 0x4e, 0x4e, 0x56, 0x49, 0x47, 0x5a, 0x65, 0x53, 0x34, 
    0x4f, 0x64, 0x2b, 0x62, 0x54, 0x49, 0x48, 0x55, 0x45, 0x6a, 0x65, 0x42, 0x61, 0x45, 0x6d, 0x50, 
    0x71, 0x51, 0x6c, 0x33, 0x4c, 0x5a, 0x4a, 0x58, 0x56, 0x52, 0x74, 0x35, 0x6d, 0x67, 0x45, 0x58, 
    0x78, 0x5a, 0x69, 0x54, 0x75, 0x62, 0x63, 0x72, 0x79, 0x2f, 0x4a, 0x46, 0x59, 0x2f, 0x37, 0x53, 
    0x36, 0x59, 0x4c, 0x69, 0x73, 0x39, 0x58, 0x6c, 0x59, 0x79, 0x2b, 0x7a, 0x75, 0x37, 0x54, 0x58, 
    0x6d, 0x4d, 0x41, 0x2f, 0x4d, 0x49, 0x4a, 0x67, 0x47, 0x49, 0x52, 0x45, 0x57, 0x47, 0x37, 0x51, 
    0x63, 0x6e, 0x61, 0x51, 0x59, 0x69, 0x6f, 0x35, 0x75, 0x76, 0x72, 0x32, 0x39, 0x6c, 0x71, 0x50, 
    0x63, 0x33, 0x6e, 0x6b, 0x76, 0x53, 0x76, 0x4f, 0x44, 0x44, 0x53, 0x59, 0x63, 0x6c, 0x62, 0x74, 
    0x48, 0x32, 0x66, 0x62, 0x65, 0x66, 0x53, 0x74, 0x68, 0x6d, 0x50, 0x74, 0x79, 0x78, 0x66, 0x66, 
    0x56, 0x50, 0x41, 0x67, 0x39, 0x4c, 0x31, 0x57, 0x66, 0x69, 0x6b, 0x6b, 0x35, 0x54, 0x38, 0x6a, 
    0x63, 0x6f, 0x4c, 0x30, 0x2b, 0x46, 0x52, 0x57, 0x43, 0x35, 0x6f, 0x6c, 0x77, 0x2f, 0x6f, 0x44, 
    0x51, 0x73, 0x64, 0x44, 0x68, 0x47, 0x52, 0x47, 0x31, 0x73, 0x46, 0x48, 0x39, 0x35, 0x71, 0x36, 
    0x73, 0x59, 0x57, 0x75, 0x56, 0x77, 0x52, 0x55, 0x59, 0x6f, 0x4c, 0x5a, 0x67, 0x42, 0x4b, 0x58, 
    0x47, 0x4b, 0x2f, 0x45, 0x42, 0x72, 0x6a, 0x7a, 0x4e, 0x66, 0x55, 0x43, 0x46, 0x36, 0x72, 0x70, 
    0x44, 0x5a, 0x35, 0x73, 0x53, 0x46, 0x65, 0x50, 0x36, 0x71, 0x30, 0x6a, 0x4e, 0x7a, 0x2b, 0x2f, 
    0x31, 0x68, 0x38, 0x79, 0x42, 0x41, 0x46, 0x42, 0x41, 0x79, 0x65, 0x6a, 0x30, 0x68, 0x33, 0x31, 
    0x4b, 0x6e, 0x6e, 0x50, 0x69, 0x6b, 0x55, 0x6c, 0x77, 0x6a, 0x42, 0x4d, 0x6a, 0x64, 0x6f, 0x62, 
    0x61, 0x68, 0x49, 0x45, 0x50, 0x39, 0x4f, 0x61, 0x71, 0x64, 0x7a, 0x6a, 0x43, 0x50, 0x4a, 0x75, 
    0x41, 0x41, 0x47, 0x38, 0x54, 0x6d, 0x49, 0x6d, 0x32, 0x52, 0x4a, 0x63, 0x2f, 0x4a, 0x64, 0x63
};

CHAR Base64in[] = "AAEAAKxzEDXKx9JIS0ExNTMyQUIwMDIwODhBMDAwIAAAAQBQyrcGt8S23KEe9LOdrny0uzPkejdQVeFwRR3h0QfVNUElRcJwijLQ43IvAn8H4u4faSFvJ+F/rTZKOUXuoLfEnBBUZSQRbFUmCLGCtO3pni1uLpeQArRl7qFzxE9QYMXFQnTlO5760U3NKuA5APwZJruNOJ+g+B6IzIGkEVOuulVTa5+srJsvmFXpidvgI4/flVLWKxOsUKzWhVvuBb89C5kNEBdfJXCu6GUFVLZs5Pv7KBIdsK43DGy6KSxPaStsncFs1xABzbNfl5g04IVX3npXBdVUONzSakQAuf8wYRawi/DV/wAFONAGfGjMrENlnh00UAaNLnDhS2zc/1SLeH2gEug2y+PxLa0Cvrl6eAoEfkVptKSfZ+WJFyZD36pVFmaDthWOoXG1g+m2TDtYbGoThqhwYlNqQ4tv4k/brMosn5Rnk2WjYPPrgdx3roHH";
/*
 *******************************************************************************
 *                               FUNCTIONS IMPLEMENT
 *******************************************************************************
*/
void l_Aes_Test(CHAR* operMode, CHAR* aesMode)
{
    if(0 == memcmp(operMode, "enc", 3))
    {
        TF("Entry aes enc operaton\n");
        /* The result of AES-ENC-CBC should like the value
           in the variable of g_AesEncCbcBuf*/
        if(0 == memcmp(aesMode, "cbc", 3))
        {
            TF("enc-cbc Input data length: 0x%x\n", sizeof(g_AesRawBuf));
            TF("Input data just like follow:\n");
            g_CA_PrintfBuffer(g_AesRawBuf, sizeof(g_AesRawBuf));
            
            g_CryptoVerifyCa_Aes(g_AesRawBuf, sizeof(g_AesRawBuf), EN_MODE_CBC, EN_OP_AES_ENCRYPT, g_AesOutpUT);
        }
        
        /* The result of AES-ENC-ECB should like the value
           in the variable of g_AesEncEcbBuf*/
        if(0 == memcmp(aesMode, "ecb", 3))
        {
            TF("enc-ecb Input data length: 0x%x\n", sizeof(g_AesEcbRawBuf));
            TF("Input data just like follow:\n");
            g_CA_PrintfBuffer(g_AesEcbRawBuf, sizeof(g_AesEcbRawBuf));
            
            g_CryptoVerifyCa_Aes(g_AesEcbRawBuf, sizeof(g_AesEcbRawBuf), EN_MODE_ECB, EN_OP_AES_ENCRYPT, g_AesOutpUT);
        }
        
        /* The result of AES-ENC-ECB should like the value
           in the variable of g_AesEncCtrBuf*/
        if(0 == memcmp(aesMode, "ctr", 3))
        {
            TF("enc-ctr Input data length: 0x%x\n", sizeof(g_AesRawBuf));
            TF("Input data just like follow:\n");
            g_CA_PrintfBuffer(g_AesRawBuf, sizeof(g_AesRawBuf));
            
            g_CryptoVerifyCa_Aes(g_AesRawBuf, sizeof(g_AesRawBuf), EN_MODE_CTR, EN_OP_AES_ENCRYPT, g_AesOutpUT);
        }
        
        /* The result of aes-enc-cts may be wrong beacause the result is different from openssl,
            So maybe someone can verify this and tell me the result*/
        if(0 == memcmp(aesMode, "cts", 3))
        {
            TF("enc-cts Input data length: 0x%x\n", sizeof(g_AesRawBuf));
            TF("Input data just like follow:\n");
            g_CA_PrintfBuffer(g_AesRawBuf, sizeof(g_AesRawBuf));
            
            g_CryptoVerifyCa_Aes(g_AesRawBuf, sizeof(g_AesRawBuf), EN_MODE_CBC_CTS, EN_OP_AES_ENCRYPT, g_AesOutpUT);
        }
    }
    else if(0 == memcmp(operMode, "dec", 3))
    {
        TF("Entry aes dec operaton\n");
        /* The result of AES-DEC-CBC should like the value
           in the variable of g_AesRawBuf*/
        if(0 == memcmp(aesMode, "cbc", 3))
        {
            TF("dec-cbc  Input data length: 0x%x\n", sizeof(g_AesEncCbcBuf));
            TF("Input data just like follow:\n");
            g_CA_PrintfBuffer(g_AesEncCbcBuf, sizeof(g_AesEncCbcBuf));
            
            g_CryptoVerifyCa_Aes(g_AesEncCbcBuf, sizeof(g_AesEncCbcBuf), EN_MODE_CBC, EN_OP_AES_DECRYPT, g_AesOutpUT);
        }
        
        /* The result of AES-DEC-CBC should like the value
           in the variable of g_AesEcbRawBuf*/
        if(0 == memcmp(aesMode, "ecb", 3))
        {
            TF("dec-ecb  Input data length: 0x%x\n", sizeof(g_AesEncEcbBuf));
            TF("Input data just like follow:\n");
            g_CA_PrintfBuffer(g_AesEncEcbBuf, sizeof(g_AesEncEcbBuf));
            
            g_CryptoVerifyCa_Aes(g_AesEncEcbBuf, sizeof(g_AesEncEcbBuf), EN_MODE_ECB, EN_OP_AES_DECRYPT, g_AesOutpUT);
        }
        
        /* The result of AES-DEC-CBC should like the value
           in the variable of g_AesRawBuf*/
        if(0 == memcmp(aesMode, "ctr", 3))
        {
            TF("dec-ctr  Input data length: 0x%x\n", sizeof(g_AesEncCtrBuf));
            TF("Input data just like follow:\n");
            g_CA_PrintfBuffer(g_AesEncCtrBuf, sizeof(g_AesEncCtrBuf));
            
            g_CryptoVerifyCa_Aes(g_AesEncCtrBuf, sizeof(g_AesEncCtrBuf), EN_MODE_CTR, EN_OP_AES_DECRYPT, g_AesOutpUT);  
        }
        
        if(0 == memcmp(aesMode, "cts", 3))
        {
            TF("dec-cts  Input data length: 0x%x\n", sizeof(g_AesEncCtsBuf));
            TF("Input data just like follow:\n");
            g_CA_PrintfBuffer(g_AesEncCtsBuf, sizeof(g_AesEncCtsBuf));
            
            g_CryptoVerifyCa_Aes(g_AesEncCtsBuf, sizeof(g_AesEncCtsBuf), EN_MODE_CBC_CTS, EN_OP_AES_DECRYPT, g_AesOutpUT);
        }
    }
    else
    {
    }

}






void l_Rsa_Test(CHAR* operFlag, EN_RSA_KEY_TYPE keyType, CHAR* output, UINT32 outputLen)
{
    RsaCaPara l_rsaPara;
    l_rsaPara.m_pOutput = output;
    l_rsaPara.m_OutputLen = outputLen;
    l_rsaPara.Rsa_Elect = keyType;

    if(0 == memcmp(operFlag, "sign", 4))
    {
        l_rsaPara.m_pInput = g_RsaPaddingRaw1;
        l_rsaPara.m_InputLen = sizeof(g_RsaPaddingRaw1);
        l_rsaPara.cmdId = CMD_RSA_SIGN_PKCS1_OPER;
    }
    else if(0 == memcmp(operFlag, "verify", 6))
    {
        l_rsaPara.m_pInput = g_RsaPcks1Verify1;
        l_rsaPara.m_InputLen = 128U;
        l_rsaPara.cmdId = CMD_RSA_VERIFY_PKCS1_OPER;
    }
    else if(0 == memcmp(operFlag, "enc", 3))
    {
        l_rsaPara.m_pInput = g_RsaPaddingRaw1;
        l_rsaPara.m_InputLen = sizeof(g_RsaPaddingRaw1);
        l_rsaPara.cmdId = CMD_RSA_ENC_PKCS1_OPER;
    }
    else if(0 == memcmp(operFlag, "dec", 3))
    {
        l_rsaPara.m_pInput = g_RsaPcks1Dec1;
        l_rsaPara.m_InputLen = 128U;
        l_rsaPara.cmdId = CMD_RSA_DEC_PKCS1_OPER;
    }
    else
    {
    }

    TF("CA send to TA data just like follow:\n");
    g_CA_PrintfBuffer(l_rsaPara.m_pInput, l_rsaPara.m_InputLen);
    g_CryptoVerifyCa_Rsa(l_rsaPara);
}


void l_Rsa2048_Test(CHAR* operFlag, EN_RSA_KEY_TYPE keyType, CHAR* output, UINT32 outputLen)
{
    RsaCaPara l_rsaPara;

    l_rsaPara.m_pOutput = output;
    l_rsaPara.m_OutputLen = outputLen;
    l_rsaPara.Rsa_Elect = keyType;
    
    if(0 == memcmp(operFlag, "sign", 4))
    {
        l_rsaPara.m_pInput = g_RsaPaddingRaw2;
        l_rsaPara.m_InputLen = sizeof(g_RsaPaddingRaw2);
        l_rsaPara.cmdId = CMD_RSA_SIGN_PKCS1_OPER;
    }
    else if(0 == memcmp(operFlag, "verify", 6))
    {
        l_rsaPara.m_pInput = g_RsaPcks1Verify2;
        l_rsaPara.m_InputLen = 256U;
        l_rsaPara.cmdId = CMD_RSA_VERIFY_PKCS1_OPER;
    }
    
    else if(0 == memcmp(operFlag, "enc", 3))
    {
        l_rsaPara.m_pInput = g_RsaPaddingRaw2;
        l_rsaPara.m_InputLen = sizeof(g_RsaPaddingRaw2);
        l_rsaPara.cmdId = CMD_RSA_ENC_PKCS1_OPER;
    }
    else if(0 == memcmp(operFlag, "dec", 3))
    {
        l_rsaPara.m_pInput = g_RsaPcks1Dec2;
        l_rsaPara.m_InputLen = 256U;
        l_rsaPara.cmdId = CMD_RSA_DEC_PKCS1_OPER;
    }
    else
    {
    }

    TF("CA send to TA data just like follow:\n");
    g_CA_PrintfBuffer(l_rsaPara.m_pInput, l_rsaPara.m_InputLen);
    g_CryptoVerifyCa_Rsa(l_rsaPara);
}











/** @ingroup MOUDLE_NAME_C_
 *- #Description  This function for handle command.
 * @param   pMsg           [IN] The received request message
 *                               - Type: MBX_Msg *
 *                               - Range: N/A.
 *
 * @return     void
 * @retval     void
 *
 *
 */
int main(int argc, char *argv[])
{
    
    if(0 == memcmp(argv[1], "random", 6))
    {
        TF("Entry get random CA\n");
        g_CryptoVerifyCa_Random(atoi(argv[2]), g_RandomOut);
        TF("The Respond random from TA just like follow:\n");
        g_CA_PrintfBuffer(g_RandomOut, atoi(argv[2]));
    }

    /* The sha1 result should be:
    0x21, 0x9b, 0x5b, 0x8b, 0x25, 0x6f, 0x0e, 0x52, 0xcb, 0x2f, 0xfe, 0xfd, 0x6c, 0x47, 0xd7, 0xb4,
    0x44, 0x00, 0x57, 0xc3
    */
    if(0 == memcmp(argv[1], "sha1", 4))
    {
        TF("Entry sha1 CA\n");
        g_CryptoVerifyCa_Sha(g_ShaTestBuf, sizeof(g_ShaTestBuf), EN_OP_SHA1, g_ShaOutput, 20);
        TF("The Respond hash data from TA just like follow:\n");
        g_CA_PrintfBuffer(g_ShaOutput, 20);
    }


    /* The sha256 result should be:
    0xda, 0x52, 0xe9, 0xc2, 0x53, 0xae, 0x03, 0x30, 0xbd, 0x97, 0x3f, 0xa5, 0xf3, 0xea, 0x51, 0x1d, 
    0x31, 0x0a, 0xdf, 0x1f, 0x0a, 0xc0, 0x0e, 0x62, 0x0f, 0x2d, 0x5e, 0x99, 0xf5, 0xc8, 0x6b, 0x8f
    */
    if(0 == memcmp(argv[1], "sha256", 6))
    {
        TF("Entry sha256 CA\n");
        g_CryptoVerifyCa_Sha(g_ShaTestBuf, sizeof(g_ShaTestBuf), EN_OP_SHA256, g_ShaOutput, 32);
        TF("The Respond hash data from TA just like follow:\n");
        g_CA_PrintfBuffer(g_ShaOutput, 32);
    }
    
    if(0 == memcmp(argv[1], "hmac", 4))
    {
        TF("Entry hmac CA\n");
        g_CryptoVerifyCa_hmac(atoi(argv[2]), g_HmacOutput, atoi(argv[3]));
        TF("The Respond HMAC data from TA just like follow:\n");
        g_CA_PrintfBuffer(g_HmacOutput, atoi(argv[2]));
    }

    if(0 == memcmp(argv[1], "base64", 6))
    {
        TF("Entry base64 CA\n");
        if(0 == memcmp(argv[2], "enc", 3))
        {
            g_CryptoVerifyCa_base64(g_Base64Raw, 372, g_Base64out, 500, 1U);
        }
        else if(0 == memcmp(argv[2], "dec", 3))
        {
            g_CryptoVerifyCa_base64(g_Base64enced, 496, g_Base64out, 500, 2U);
        }
        TF("The Respond HMAC data from TA just like follow:\n");
        g_CA_PrintfBuffer(g_Base64out, 500);
    }
    


    if(0 == memcmp(argv[1], "aes", 3))
    {
        TF("Entry aes operaton\n");
        memset(g_AesOutpUT, 0, 256);
        l_Aes_Test(argv[2], argv[3]);
        g_CA_PrintfBuffer(g_AesOutpUT, 80);
    }


    if(0 == memcmp(argv[1], "pbkdf", 5))
    {
        TF("Entry generate pbkdf CA\n");
        g_CryptoVerifyCa_Pbkdf(atoi(argv[2]), g_PbkdfOut);
        g_CA_PrintfBuffer(g_PbkdfOut, atoi(argv[2]));
    }

    if(0 == memcmp(argv[1], "rsa1024", 7))
    {
        TF("Entry rsa1024 operation\n");
        /* rsa1024 + sign/verify/enc/dec + pcks1/nopadding */
        l_Rsa_Test(argv[2], EN_KEY_1024, g_Output1024, 128);
        if(0 == memcmp(argv[2], "verify", 6))
        {
            TF("The verify result is: %s\n", g_Output1024);
        }
    }  

    if(0 == memcmp(argv[1], "rsa2048", 7))
    {
        TF("Entry rsa1024 operation\n");
        /* rsa1024 + sign/verify/enc/dec + pcks1/nopadding */
        l_Rsa2048_Test(argv[2], EN_KEY_2048, g_Output2048, 256);
        if(0 == memcmp(argv[2], "verify", 6))
        {
            TF("The verify result is: %s\n", g_Output2048);
        }
    }  
    return 0;
}





























/**
 * @}
 */
